@startuml AEFI_Domain_Model

!define VALUE_OBJECT #FFEAA7
!define ENTITY #74B9FF
!define AGGREGATE_ROOT #FD79A8
!define SERVICE #DFE6E9

' ============= VALUE OBJECTS =============

package "Value Objects" <<Rectangle>> {
  
  ' --- Spatial Value Objects ---
  package "Spatial" <<Folder>> {
    
    class Position1D <<value object>> VALUE_OBJECT {
      +value: float
      +axis: AxisDirection
      --
      +equals(other: Position1D): boolean
      +toPosition2D(otherAxis: float): Position2D
      +toPosition3D(y: float, z: float): Position3D
    }
    
    class Position2D <<value object>> VALUE_OBJECT {
      +x: float
      +y: float
      --
      +distanceTo(other: Position2D): float
      +equals(other: Position2D): boolean
    }
    
    class Position3D <<value object>> VALUE_OBJECT {
      +x: float
      +y: float
      +z: float
      --
      +distanceTo(other: Position3D): float
      +toPosition2D(): Position2D
      +equals(other: Position3D): boolean
    }
    
    class Vector3D <<value object>> VALUE_OBJECT {
      +x: float
      +y: float
      +z: float
      --
      +magnitude(): float
      +normalize(): Vector3D
      +dotProduct(other: Vector3D): float
      +crossProduct(other: Vector3D): Vector3D
      +equals(other: Vector3D): boolean
    }
    
    class FrameRotation <<value object>> VALUE_OBJECT {
      +quaternion: Quaternion
      +eulerAngles: EulerAngles
      --
      +rotate(vector: Vector3D): Vector3D
      +inverse(): FrameRotation
      +compose(other: FrameRotation): FrameRotation
    }
    
    class SpatialRange <<value object>> VALUE_OBJECT {
      +min: float
      +max: float
      +step: float
      --
      +numberOfPoints(): int
      +contains(value: float): boolean
      +validate(): ValidationResult
    }
    
    class ScanBounds <<value object>> VALUE_OBJECT {
      +xRange: SpatialRange
      +yRange: SpatialRange
      --
      +contains(position: Position2D): boolean
      +area(): float
      +totalPoints(): int
    }
    
    class ScanAxis <<value object>> VALUE_OBJECT {
      +direction: AxisDirection
      +range: SpatialRange
      --
      +getPositions(): List<float>
    }

    class Vector2D <<value object>> VALUE_OBJECT {
      +x: float
      +y: float
      --
      +magnitude(): float
      +normalize(): Vector2D
    }

    class TestBench <<value object>> VALUE_OBJECT {
      +dimensions: Dimensions2D
      +homePosition: Position2D
      +origin: Position2D
      --
      +getQuadrant(position: Position2D): Quadrant
    }
    
    class SensorFrame <<value object>> VALUE_OBJECT {
      +origin: Position3D
      +orientation: FrameRotation
      --
      +toGlobal(localPos: Position3D): Position3D
      +toLocal(globalPos: Position3D): Position3D
    }
  }
  
  ' --- Acquisition Value Objects ---
  package "Acquisition" <<Folder>> {
    
    class ExcitationSignal <<value object>> VALUE_OBJECT {
      +modulationFrequency: Frequency
      +amplitudePercent: float
      --
      +equals(other: ExcitationSignal): boolean
    }
    
    class ExcitationConfig <<value object>> VALUE_OBJECT {
      +mode: ExcitationMode
      +signal: ExcitationSignal
      +phaseDDS1Rad: float
      +phaseDDS2Rad: float
      --
      +getPhasesDegrees(): Tuple<float, float>
      +equals(other: ExcitationConfig): boolean
    }
    
    class Frequency <<value object>> VALUE_OBJECT {
      +hertz: float
      --
      +toOmega(): float
      +toMegahertz(): float
      +equals(other: Frequency): boolean
    }
    
    class Duration <<value object>> VALUE_OBJECT {
      +milliseconds: long
      --
      +toSeconds(): float
      +toMicroseconds(): long
      +add(other: Duration): Duration
    }
    
    class Measurement <<value object>> VALUE_OBJECT {
      +value: Complex
      +unit: string
      +timestamp: DateTime
      --
      +isValid(): boolean
      +equals(other: Measurement): boolean
    }
    
    class VoltageMeasurement <<value object>> VALUE_OBJECT {
      +voltage: Complex
      --
      +toElectricField(calibration: CalibrationData): Vector3D
    }
    
    class RelativeMeasurement <<value object>> VALUE_OBJECT {
      +totalField: Vector3D
      +referenceField: Vector3D
      +scatteredField: Vector3D
      +relativeChange: Complex
      --
      +computeScatteredField(): Vector3D
      +getComplexContrast(): Complex
    }
    
    class AcquisitionParameters <<value object>> VALUE_OBJECT {
      +frequency: Frequency
      +excitation: ExcitationConfig
      +samplingRate: Frequency
      +integrationTime: Duration
      +amplification: float
      --
      +equals(other: AcquisitionParameters): boolean
      +validate(): ValidationResult
    }
  }
  
  ' --- Identifiers (Lazy Wrappers) ---
  package "Identifiers" <<Folder>> {
    
    class ScanId <<value object>> VALUE_OBJECT {
      +value: UUID
      --
      +toString(): string
      +equals(other: ScanId): boolean
    }
    
    class StudyId <<value object>> VALUE_OBJECT {
      +value: UUID
      --
      +toString(): string
      +equals(other: StudyId): boolean
    }
    
    class MeasurementId <<value object>> VALUE_OBJECT {
      +value: UUID
      --
      +toString(): string
      +equals(other: MeasurementId): boolean
    }
    
    class ReferenceId <<value object>> VALUE_OBJECT {
      +value: UUID
      --
      +toString(): string
      +equals(other: ReferenceId): boolean
    }
    
    class CalibrationId <<value object>> VALUE_OBJECT {
      +value: UUID
      --
      +toString(): string
      +equals(other: CalibrationId): boolean
    }
    
    class SourceId <<value object>> VALUE_OBJECT {
      +value: string
      --
      +toString(): string
      +equals(other: SourceId): boolean
    }
    
    class SensorId <<value object>> VALUE_OBJECT {
      +value: string
      --
      +toString(): string
      +equals(other: SensorId): boolean
    }
    
    class ColumnId <<value object>> VALUE_OBJECT {
      +value: string
      --
      +toString(): string
      +equals(other: ColumnId): boolean
    }
    
    class TestBenchId <<value object>> VALUE_OBJECT {
      +value: string
      --
      +toString(): string
      +equals(other: TestBenchId): boolean
    }
  }
  
  ' --- Status Enums (State, not event metadata) ---
  package "Status" <<Folder>> {
    
    enum ScanStatus {
      PENDING
      RUNNING
      PAUSED
      COMPLETED
      FAILED
      CANCELLED
    }
    
    enum StudyStatus {
      CREATED
      CONFIGURED
      IN_PROGRESS
      COMPLETED
      ARCHIVED
    }
    
    enum ExcitationMode {
      OFF
      X_DIR
      Y_DIR
      CIRCULAR_PLUS
      CIRCULAR_MINUS
      CUSTOM
    }
    
    enum AxisDirection {
      X_AXIS
      Y_AXIS
      Z_AXIS
    }

    enum Quadrant {
      X_POS_Y_POS
      X_NEG_Y_POS
      X_NEG_Y_NEG
      X_POS_Y_NEG
    }
  }
  
  ' --- Complex Types (Wrappers) ---
  package "Complex Types" <<Folder>> {
    
    class Complex <<value object>> VALUE_OBJECT {
      +real: float
      +imaginary: float
      --
      +magnitude(): float
      +phase(): float
      +conjugate(): Complex
      +add(other: Complex): Complex
      +multiply(other: Complex): Complex
    }
    
    class Quaternion <<value object>> VALUE_OBJECT {
      +w: float
      +x: float
      +y: float
      +z: float
      --
      +normalize(): Quaternion
      +conjugate(): Quaternion
      +multiply(other: Quaternion): Quaternion
    }
    
    class EulerAngles <<value object>> VALUE_OBJECT {
      +roll: float
      +pitch: float
      +yaw: float
      --
      +toQuaternion(): Quaternion
      +toRadians(): EulerAngles
    }
  }
}

' ============= ENTITIES =============

package "Entities" <<Rectangle>> {
  
  class SphericalSource <<entity>> ENTITY {
    +id: SourceId
    +quadrant: Quadrant
    +positionOnColumn: Position3D
    --
    +getExcitationField(target: Position3D): Vector3D
  }

  class CubicSensor3D <<entity>> ENTITY {
    +id: SensorId
    +dimensions: Dimensions3D
    +frame: SensorFrame
    +bandwidth: Frequency
    +gain: float
    --
    +getMeasurementPoint(): Position3D
  }

  class Column <<entity>> ENTITY {
    +id: ColumnId
    +dimensions: Dimensions2D
    +position: Position2D
    +sources: List<SphericalSource>
    --
    +moveTo(position: Position2D): void
    +moveRelative(delta: Vector2D): void
    +home(): void
    +stop(): void
    +setVelocity(speed: float): void
    +getSourcePosition(sourceId: SourceId): Position3D
  }

  class SourceSensorAssociation <<entity>> ENTITY {
    +source: SphericalSource
    +sensor: CubicSensor3D
    +relativePosition: Vector3D
    --
    +isValid(): boolean
  }

  class MeasurementPoint <<entity>> ENTITY {
    +id: MeasurementPointId
    +position: Position2D
    +voltage: VoltageMeasurement
    +parameters: AcquisitionParameters
    +timestamp: DateTime
    --
    +computeRelativeTo(reference: ReferenceMeasurement): RelativeMeasurement
  }
  
  class ReferenceMeasurement <<entity>> ENTITY {
    +id: ReferenceId
    +voltage: VoltageMeasurement
    +position: Position2D
    +acquisitionTime: DateTime
    +parameters: AcquisitionParameters
    +metadata: MeasurementMetadata
    --
    +isValidFor(parameters: AcquisitionParameters): boolean
  }
  
  class ScanConfiguration <<entity>> ENTITY {
    +id: ConfigurationId
    +type: ScanType
    +bounds: ScanBounds
    +stepSize: Distance
    +scanMode: ScanMode
    +acquisitionParameters: AcquisitionParameters
    --
    +validate(): ValidationResult
    +generateScanPlan(): ScanPlan
  }
}

' ============= AGGREGATES =============

package "Aggregate Roots" <<Rectangle>> {

  class TestBench <<aggregate root>> AGGREGATE_ROOT {
    +id: TestBenchId
    +dimensions: Dimensions2D
    +homePosition: Position2D
    +origin: Position2D
    +column: Column
    +associations: List<SourceSensorAssociation>
    --
    +getQuadrant(position: Position2D): Quadrant
    +configureAssociation(sourceId: SourceId, sensorId: SensorId): void
  }


  
  class ManualScan <<aggregate root>> AGGREGATE_ROOT {
    +id: ScanId
    +scanType: ScanType.MANUAL
    +reference: ReferenceMeasurement
    -measurements: List<MeasurementPoint>
    +startTime: DateTime
    +endTime: DateTime
    +status: ScanStatus
    --
    +addMeasurementPoint(point: MeasurementPoint): void
    +updateParameters(params: AcquisitionParameters): void
    +finalize(): StructuredScanData
    +getMeasurements(): List<MeasurementPoint>
  }
  
  class AutomaticScan <<aggregate root>> AGGREGATE_ROOT {
    +id: ScanId
    +scanType: ScanType
    +configuration: ScanConfiguration
    +reference: ReferenceMeasurement
    -spatialGrid: SpatialGrid
    -measurements: Map<Position2D, MeasurementPoint>
    +startTime: DateTime
    +endTime: DateTime
    +status: ScanStatus
    --
    +addMeasurement(position: Position2D, measurement: VoltageMeasurement): void
    +getStructuredData(): StructuredScanData
    +getSpatialGrid(): SpatialGrid
  }
  
  class CustomScan <<aggregate root>> AGGREGATE_ROOT {
    +id: ScanId
    +scanType: ScanType.CUSTOM
    +reference: ReferenceMeasurement
    -sequence: CustomSequence
    -measurements: List<MeasurementPoint>
    +startTime: DateTime
    +endTime: DateTime
    +status: ScanStatus
    --
    +defineSequence(name: string): void
    +addScanPoint(point: CustomScanPoint): void
    +executionCompleted(): void
    +getSequence(): CustomSequence
  }
  
  class StabilityAcquisition <<aggregate root>> AGGREGATE_ROOT {
    +id: AcquisitionId
    +reference: ReferenceMeasurement
    -timeSeries: List<TimestampedMeasurement>
    +startTime: DateTime
    +endTime: DateTime
    +samplingRate: Frequency
    +status: AcquisitionStatus
    --
    +addMeasurement(measurement: TimestampedMeasurement): void
    +stop(): void
    +getTimeSeries(): List<TimestampedMeasurement>
    +computeStabilityMetrics(): StabilityMetrics
  }
}

' ============= DOMAIN TYPES =============

package "Domain Types" <<Rectangle>> {
  
  class SpatialGrid <<value object>> VALUE_OBJECT {
    +dimensions: GridDimensions
    +spacing: GridSpacing
    +bounds: ScanBounds
    --
    +getTotalPoints(): int
    +getPositionAt(i: int, j: int): Position2D
  }
  
  class GridDimensions <<value object>> VALUE_OBJECT {
    +nx: int
    +ny: int
  }
  
  class GridSpacing <<value object>> VALUE_OBJECT {
    +dx: float
    +dy: float
  }
  
  class CustomSequence <<entity>> ENTITY {
    +id: SequenceId
    +name: string
    -points: List<CustomScanPoint>
    --
    +addPoint(point: CustomScanPoint): void
    +getPoints(): List<CustomScanPoint>
    +validate(): ValidationResult
  }
  
  class CustomScanPoint <<value object>> VALUE_OBJECT {
    +position: Position2D
    +acquisitionDuration: Duration
    +parameters: AcquisitionParameters
    +preAcquisitionActions: List<Action>
  }
  
  class StructuredScanData <<value object>> VALUE_OBJECT {
    +scanId: ScanId
    +scanType: ScanType
    +reference: ReferenceMeasurement
    +spatialGrid: SpatialGrid
    +measurements: Map<Position2D, List<RelativeMeasurement>>
    +metadata: ScanMetadata
    --
    +getFieldComponent(component: FieldComponent): Matrix2D
  }
  

}

' ============= ENUMERATIONS =============

enum ScanType {
  MANUAL
  SERPENTINE
  COMB
  CUSTOM
  STABILITY
}

enum ScanMode {
  STEP
  FLY
}

enum ScanStatus {
  INITIALIZED
  IN_PROGRESS
  PAUSED
  COMPLETED
  FAILED
}

enum FieldComponent {
  EX
  EY
  EZ
}

' ============= RELATIONS =============

' Value Object relationships
AcquisitionParameters *-- Frequency
AcquisitionParameters *-- Duration
VoltageMeasurement *-- Complex
RelativeMeasurement *-- Vector3D
SpatialGrid *-- GridDimensions
SpatialGrid *-- GridSpacing
SpatialGrid *-- ScanBounds
CustomScanPoint *-- Position2D
CustomScanPoint *-- Duration
CustomScanPoint *-- AcquisitionParameters

' Entity relationships
MeasurementPoint *-- Position2D
MeasurementPoint *-- VoltageMeasurement
MeasurementPoint *-- AcquisitionParameters
ReferenceMeasurement *-- VoltageMeasurement
ReferenceMeasurement *-- Position2D
ReferenceMeasurement *-- AcquisitionParameters
ScanConfiguration *-- ScanBounds
ScanConfiguration *-- AcquisitionParameters
ScanConfiguration -- ScanType
ScanConfiguration -- ScanMode

' Aggregate relationships
ManualScan *-- "0..*" MeasurementPoint
ManualScan *-- ReferenceMeasurement
ManualScan -- ScanStatus

AutomaticScan *-- ScanConfiguration
AutomaticScan *-- ReferenceMeasurement
AutomaticScan *-- SpatialGrid
AutomaticScan *-- "0..*" MeasurementPoint
AutomaticScan -- ScanStatus

CustomScan *-- CustomSequence
CustomScan *-- ReferenceMeasurement
CustomScan *-- "0..*" MeasurementPoint
CustomScan -- ScanStatus

CustomSequence *-- "1..*" CustomScanPoint

StabilityAcquisition *-- ReferenceMeasurement
StabilityAcquisition *-- "0..*" MeasurementPoint

StructuredScanData *-- ReferenceMeasurement
StructuredScanData *-- SpatialGrid
StructuredScanData -- ScanType



' Link to inverse problem


note right of StructuredScanData
  Output format for persistence
  
  Structure:
  - E_mes(r_i, ω): N_x × N_y × 3
  - E_0(r_i, ω): reference field
  - Spatial grid metadata
end note



note bottom of ManualScan
  Aggregate Root
  Encapsulates manual scan workflow
  Maintains invariants:
  - All measurements use same reference
  - Parameters can change between points
end note

note bottom of AutomaticScan
  Aggregate Root
  Encapsulates automated scan patterns
  Maintains invariants:
  - Complete spatial grid coverage
  - Consistent parameters across scan
end note

@enduml
