# AEFI Application Layer - Services Architecture

## 1. Services d'Acquisition

### 1.1 StabilityAcquisitionService
**Responsabilité**: Gestion des acquisitions de stabilité temporelle

**Méthodes**:
- `startTimedAcquisition(startTime: DateTime, endTime?: DateTime): AcquisitionId`
  - Lance une acquisition qui démarre à un instant donné
  - Optionnel: fin prédéterminée ou contrôle manuel
  
- `stopAcquisition(acquisitionId: AcquisitionId): void`
  - Arrêt utilisateur d'une acquisition en cours
  
- `acquireForDuration(duration: Duration, samplingRate: Frequency): AcquisitionId`
  - Acquisition sur une durée fixe avec fréquence d'échantillonnage

**Dépendances**: ReferenceMeasurementService, DataAggregationService

---

### 1.2 ManualScanService
**Responsabilité**: Gestion des scans manuels point par point

**Méthodes**:
- `acquireAtCurrentPosition(parameters: AcquisitionParameters): MeasurementPoint`
  - Acquisition au point courant avec paramètres donnés
  
- `moveAndAcquire(position: Position2D, parameters: AcquisitionParameters): MeasurementPoint`
  - Déplacement puis acquisition
  
- `updateParametersBeforeNext(parameters: AcquisitionParameters): void`
  - Modification des paramètres entre deux acquisitions
  
- `finalizeManualScan(scanId: ScanId): StructuredScanData`
  - Finalisation et agrégation structurée du scan manuel

**Dépendances**: MotionControlService, ReferenceMeasurementService, DataAggregationService, ParameterManagementService

---

### 1.3 AutomaticScanService
**Responsabilité**: Exécution de scans automatiques avec patterns prédéfinis

**Méthodes**:
- `configureScanPattern(config: ScanConfiguration): ScanPlan`
  - Configuration du pattern spatial (serpentin, peigne, custom)
  
- `executeSerpentineScan(bounds: ScanBounds, stepSize: Distance): ScanId`
  - Exécution d'un scan en serpentin
  
- `executeCombScan(bounds: ScanBounds, stepSize: Distance): ScanId`
  - Exécution d'un scan en peigne
  
- `executeStepScan(scanPlan: ScanPlan, mode: StepMode): ScanId`
  - Scan par étape (arrêt à chaque point)
  
- `executeFlyScan(scanPlan: ScanPlan, speed: Velocity): ScanId`
  - Scan en vol (acquisition continue pendant déplacement)

**Dépendances**: MotionControlService, ScanConfigurationService, ReferenceMeasurementService, DataAggregationService

---

### 1.4 CustomScanService
**Responsabilité**: Création et exécution de séquences d'acquisition personnalisées

**Méthodes**:
- `defineCustomSequence(name: string): CustomSequenceBuilder`
  - Initialise une séquence personnalisée
  
- `addScanPoint(sequence: CustomSequence, point: CustomScanPoint): void`
  - Ajoute un point avec: position, durée, paramètres
  - Exemple: Point A → Point B (freq change) → Point A (mesure)
  
- `executeCustomScan(sequence: CustomSequence): ScanId`
  - Exécution de la séquence définie

**Types**:
```
CustomScanPoint {
  position: Position2D
  acquisitionDuration: Duration
  parameters: AcquisitionParameters
  preAcquisitionActions: Action[]
}
```

**Dépendances**: MotionControlService, ParameterManagementService, DataAggregationService, ReferenceMeasurementService

---

## 2. Gestion des Mesures

### 2.1 ReferenceMeasurementService
**Responsabilité**: Gestion du point de référence pour mesures relatives

**Méthodes**:
- `setAsReference(measurement: ElectricFieldMeasurement, context: MeasurementContext): ReferenceId`
  - Définit la mesure courante comme référence
  - Context: position, fréquence, paramètres du système
  
- `getReferenceMeasurement(): ReferenceMeasurement`
  - Récupère la référence active
  
- `computeRelativeMeasurement(measurement: ElectricFieldMeasurement): RelativeMeasurement`
  - Calcule la mesure relative à la référence
  - Retourne: E_scatter = E_total - E_0

**Types**:
```
ReferenceMeasurement {
  id: ReferenceId
  electricField: Vector3D  // E_0
  position: Position2D
  acquisitionTime: DateTime
  parameters: AcquisitionParameters
  metadata: MeasurementMetadata
}

RelativeMeasurement {
  totalField: Vector3D      // E_mes
  referenceField: Vector3D  // E_0
  scatteredField: Vector3D  // E_scatter
  relativeChange: Complex
}
```

---

### 2.2 DataAggregationService
**Responsabilité**: Agrégation structurée des données d'acquisition

**Méthodes**:
- `aggregateMeasurements(measurements: MeasurementPoint[], scanType: ScanType): StructuredScanData`
  - Agrège les points de mesure selon le type de scan
  
- `structureAcquisitionData(rawData: RawAcquisition[]): AcquisitionDataset`
  - Structure les données brutes en dataset exploitable
  - Crée la structure pour problème inverse: E_mes(r_i, ω)
  
- `linkMeasurementsToPositions(measurements: Measurement[], positions: Position2D[]): SpatialMeasurementMap`
  - Associe chaque mesure à sa position spatiale
  - Structure pour matrice de mesures N_x × N_y × 3

**Types**:
```
StructuredScanData {
  scanId: ScanId
  scanType: ScanType
  reference: ReferenceMeasurement
  spatialGrid: SpatialGrid
  measurements: Map<Position2D, RelativeMeasurement[]>
  metadata: ScanMetadata
}

SpatialGrid {
  dimensions: { nx: int, ny: int }
  spacing: { dx: float, dy: float }
  bounds: ScanBounds
}
```

---

## 3. Contrôle de Mouvement

### 3.1 MotionControlService
**Responsabilité**: Interface avec le système de déplacement XY (future: Z)

**Méthodes**:
- `moveToPosition(position: Position2D, speed?: Velocity): Promise<void>`
  - Déplacement vers une position donnée
  
- `getCurrentPosition(): Position2D`
  - Position actuelle de la colonne
  
- `calibrateAxes(): Promise<CalibrationResult>`
  - Calibration des axes X et Y

**Note**: Abstraction pour évolution future vers 3D (ajout axe Z)

---

## 4. Configuration

### 4.1 ScanConfigurationService
**Responsabilité**: Création et validation de configurations de scan

**Méthodes**:
- `createScanConfiguration(type: ScanType, parameters: ScanParameters): ScanConfiguration`
  - Crée une configuration de scan validée
  
- `validateScanPattern(config: ScanConfiguration): ValidationResult`
  - Valide la cohérence de la configuration
  
- `saveScanTemplate(config: ScanConfiguration, name: string): TemplateId`
  - Sauvegarde une configuration réutilisable

**Types**:
```
ScanConfiguration {
  type: ScanType  // SERPENTINE, COMB, CUSTOM, MANUAL
  bounds: ScanBounds
  stepSize: Distance
  scanMode: ScanMode  // STEP, FLY
  acquisitionParameters: AcquisitionParameters
}

ScanParameters {
  spatialResolution: Distance
  temporalResolution: Duration
  frequency: Frequency
}
```

---

### 4.2 ParameterManagementService
**Responsabilité**: Gestion des paramètres d'acquisition

**Méthodes**:
- `updateFrequency(frequency: Frequency): void`
  - Change la fréquence d'excitation
  
- `updateAcquisitionParams(params: AcquisitionParameters): void`
  - Mise à jour globale des paramètres
  
- `snapshotParameters(): ParameterSnapshot`
  - Capture l'état actuel des paramètres
  - Utile pour traçabilité et reproduction

**Types**:
```
AcquisitionParameters {
  frequency: Frequency  // ω
  samplingRate: Frequency
  integrationTime: Duration
  amplification: float
  filterSettings: FilterConfig
}
```

---

## 5. Persistance

### 5.1 DataPersistenceService
**Responsabilité**: Sauvegarde et chargement des acquisitions

**Méthodes**:
- `persistAcquisition(data: StructuredScanData): PersistenceId`
  - Sauvegarde complète d'une acquisition
  - Format structuré pour problème inverse
  
- `loadAcquisition(id: PersistenceId): StructuredScanData`
  - Chargement d'une acquisition sauvegardée
  
- `exportToFormat(data: StructuredScanData, format: ExportFormat): FilePath`
  - Export vers formats externes (HDF5, NetCDF, CSV)

**Formats suggérés**:
- HDF5: pour données volumineuses structurées
- JSON: pour métadonnées et configurations
- NetCDF: pour compatibilité scientifique

---

## Relations entre Services

### Flux typique - Scan Manuel:
```
User → ManualScanService.moveAndAcquire()
  → MotionControlService.moveToPosition()
  → [acquisition hardware]
  → ReferenceMeasurementService.computeRelativeMeasurement()
  → DataAggregationService.aggregateMeasurements()
  → DataPersistenceService.persistAcquisition()
```

### Flux typique - Scan Automatique:
```
User → AutomaticScanService.executeSerpentineScan()
  → ScanConfigurationService.validateScanPattern()
  → MotionControlService.moveToPosition() [loop]
  → [acquisition hardware] [loop]
  → ReferenceMeasurementService.computeRelativeMeasurement() [loop]
  → DataAggregationService.structureAcquisitionData()
  → DataPersistenceService.persistAcquisition()
```

### Flux typique - Custom Scan:
```
User → CustomScanService.defineCustomSequence()
  → CustomScanService.addScanPoint() [multiple]
  → CustomScanService.executeCustomScan()
    → ParameterManagementService.updateFrequency() [per point]
    → MotionControlService.moveToPosition() [per point]
    → [acquisition hardware] [per point]
  → DataAggregationService.linkMeasurementsToPositions()
  → DataPersistenceService.persistAcquisition()
```

---

## Considérations DDD

### Aggregate Roots potentiels:
- **Acquisition** (racine: StabilityAcquisition, ManualScan, AutomaticScan, CustomScan)
- **ReferenceMeasurement** (racine: Reference avec ses mesures associées)
- **ScanConfiguration** (racine: Configuration avec ses paramètres)

### Value Objects:
- Position2D, Vector3D
- AcquisitionParameters
- ElectricFieldMeasurement
- Duration, Frequency, Distance

### Domain Events:
- `AcquisitionStarted`
- `MeasurementAcquired`
- `ReferenceSet`
- `ScanCompleted`
- `ParametersChanged`

Ces événements permettent la réactivité et le découplage entre services.