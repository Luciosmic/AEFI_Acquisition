@startuml AEFI_Application_Layer_Refined

!define DOMAIN #E1F5FF
!define APP #FFF4E1
!define INFRA #F0E1FF
!define PORT #E1FFE1

skinparam componentStyle uml2

package "Application Layer" {
    
    class StudyService <<Application Service>> {
        +createStudy(name, objectId): StudyId
        +configureAcquisition(studyId, config): void
        +runSequence(studyId, sequenceId): void
        +exportResults(studyId): void
    }

    note right of StudyService
        Orchestrates the flow.
        Delegates actual execution to Ports.
    end note

}

package "Domain Layer (Core)" {
    
    class Study <<Aggregate Root>> {
        -id: StudyId
        -object: ExperimentObject
        -sequences: List<AcquisitionSequence>
        +addSequence(sequence): void
        +completeSequence(id, results): void
    }

    class AcquisitionSequence <<Entity>> {
        -steps: List<AcquisitionStep>
        +validate(): bool
    }

    interface ScanPort <<Port>> {
        +executeSequence(sequence: AcquisitionSequence): SequenceResult
        +abort(): void
    }

    interface ObjectRepository <<Port>> {
        +get(id: ObjectId): ExperimentObject
    }
    
    Study *-- AcquisitionSequence
}

package "Infrastructure Layer" {
    
    class RustScanAdapter <<Adapter>> {
        -engine: RustScanExecutor
        +executeSequence(sequence): SequenceResult
    }
    
    class Hdf5Repository <<Adapter>> {
        +save(study): void
    }

}

' Relationships
StudyService --> Study : manages
StudyService --> ScanPort : uses
StudyService --> ObjectRepository : uses

RustScanAdapter ..|> ScanPort : implements
Hdf5Repository ..|> ObjectRepository : implements (read-only part)

note bottom of RustScanAdapter
    Encapsulates Motion + Acquisition
    in a tight Rust loop.
    Application Layer does NOT see
    "MotionControlService" directly.
end note

@enduml
