@startuml Motion Service - Détaillé

!define RECTANGLE class

skinparam classAttributeIconSize 0
skinparam backgroundColor #FEFEFE

class MotionService {
  - _meta_manager: MetaManager
  - _position_listeners: List[Callable]
  - _homing_status: Dict[str, bool]
  
  ' === Commandes de mouvement ===
  + move_to(axis: str, target_cm: float) -> bool
  + move_to_position(x_cm: float, y_cm: float) -> bool
  + home_axis(axis: str) -> bool
  + home_both_axes() -> bool
  + home_both_axes_blocking() -> bool
  + stop_axis(axis: str, immediate: bool) -> bool
  + emergency_stop_all() -> bool
  
  ' === Configuration vitesse ===
  + set_axis_speed_params(axis: str, params: SpeedParams) -> bool
  + get_axis_speed_params(axis: str) -> SpeedParams
  + apply_speed_configuration(config: SpeedConfig) -> bool
  
  ' === Requêtes d'état ===
  + get_current_position() -> Position
  + is_axis_homed(axis: str) -> bool
  + is_moving() -> bool
  + get_axis_limits() -> AxisLimits
  
  ' === Observateurs ===
  + subscribe_position_updates(callback: Callable) -> None
  + unsubscribe_position_updates(callback: Callable) -> None
  
  ' === Méthodes internes ===
  - _validate_position(x: float, y: float) -> bool
  - _convert_cm_to_inc(value_cm: float) -> int
  - _convert_inc_to_cm(value_inc: int) -> float
  - _on_position_changed(x_inc: int, y_inc: int) -> None
  - _on_homing_completed(axis: str) -> None
}

class Position {
  + x_cm: float
  + y_cm: float
  + timestamp: datetime
}

class SpeedParams {
  + low_speed: int
  + high_speed: int
  + acceleration: int
  + deceleration: int
}

class SpeedConfig {
  + x_params: SpeedParams
  + y_params: SpeedParams
}

class AxisLimits {
  + x_min_cm: float
  + x_max_cm: float
  + y_min_cm: float
  + y_max_cm: float
}

' === Relations avec GUI ===
class "EFImagingBench_GUI" as GUI {
  + move_to(axis)
  + home(axis)
  + stop(axis)
  + apply_speed_parameters()
}

' === Relations avec Domain ===
class MetaManager {
  + move_to(axis, target_inc)
  + home_lock(axis)
  + home_both_lock()
  + stop(axis, immediate)
  + set_axis_params(axis, params)
  + get_axis_params(axis, callback)
  --
  <<signal>> position_changed
  <<signal>> status_changed
}

class StageManager {
  + add_command_to_queue(cmd)
  + get_current_position()
  + get_axis_homed_status(axis)
  --
  <<signal>> position_changed
  <<signal>> status_changed
}

' === Relations ===
GUI ..> MotionService : "utilise"
MotionService --> MetaManager : "délègue à"
MetaManager --> StageManager : "coordonne"

MotionService ..> Position : "retourne"
MotionService ..> SpeedParams : "utilise"
MotionService ..> SpeedConfig : "utilise"
MotionService ..> AxisLimits : "retourne"

note right of MotionService
  **Responsabilités:**
  - Validation des positions (limites)
  - Conversion cm ↔ inc
  - Gestion observateurs position
  - Simplification API mouvement
  - Vérification homing avant move
  
  **Principe:**
  - Pas de logique métier complexe
  - Pas de gestion de threads
  - Délègue tout au MetaManager
  - Fournit API synchrone simple
end note

note bottom of MetaManager
  Le MetaManager reste le coordinateur
  central avec gestion des threads,
  signaux Qt, et orchestration.
  
  MotionService = façade simplifiée
end note

@enduml

