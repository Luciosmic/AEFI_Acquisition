@startuml Automatic Step Scan Service - Domain Service

!define RECTANGLE class

skinparam classAttributeIconSize 0
skinparam backgroundColor #FEFEFE

' ==========================================
' DOMAIN SERVICE (Logique métier pure)
' ==========================================

class AutomaticStepScanService <<Domain Service>> {
  ' === Responsabilité ===
  ' Orchestrer la logique métier d'un scan automatique
  ' par étapes (step scan) avec acquisition à chaque point
  
  ' === Pas de dépendances infrastructure ===
  ' Ce service ne connaît PAS:
  ' - StageManager, AcquisitionManager (infrastructure)
  ' - GUI, signaux Qt (présentation)
  ' - Fichiers, CSV (infrastructure)
  
  ' === Dépendances (injection) ===
  - _motion_port: IMotionPort
  - _acquisition_port: IAcquisitionPort
  - _current_scan: Optional[SpatialScan]
  
  ' === API Publique ===
  + execute_step_scan(scan_config: StepScanConfig) -> SpatialScan
  + pause_scan() -> None
  + resume_scan() -> None
  + cancel_scan() -> None
  + get_scan_status() -> ScanStatus
  + get_scan_progress() -> ScanProgress
  
  ' === Logique métier (privée) ===
  - _validate_scan_config(config: StepScanConfig) -> ValidationResult
  - _generate_scan_trajectory(config: StepScanConfig) -> List[Position2D]
  - _execute_scan_point(position: Position2D, config: StepScanConfig) -> MeasurementResult
  - _move_to_position(position: Position2D) -> None
  - _wait_for_stabilization(delay_ms: int) -> None
  - _acquire_measurements(averaging_per_scan_point: int) -> List[VoltageMeasurement]
  - _average_measurements(measurements: List[VoltageMeasurement]) -> VoltageMeasurement
  - _check_scan_should_continue() -> bool
}

' ==========================================
' VALUE OBJECTS (Configuration)
' ==========================================

class StepScanConfig <<Value Object>> {
  + scan_zone: ScanZone
  + x_nb_points: int
  + y_nb_points: int
  + scan_mode: ScanMode
  + stabilization_delay_ms: int
  + averaging_per_scan_point: int
  + measurement_uncertainty: MeasurementUncertainty
  
  + validate() -> ValidationResult
  + total_points() -> int
  + estimated_duration_seconds() -> float
}

class ScanZone <<Value Object>> {
  + x_min: float
  + x_max: float
  + y_min: float
  + y_max: float
  
  + __post_init__() -> None
  + contains(position: Position2D) -> bool
  + area() -> float
  + center() -> Position2D
  
  ' Validation limites physiques
  ' PHYSICAL_X_MAX = 120.0 cm (hardcodé)
  ' PHYSICAL_Y_MAX = 120.0 cm (hardcodé)
  ' TODO: injecter depuis TestBench entity
}

enum ScanMode <<Value Object>> {
  SERPENTINE
  RASTER
  COMB
}

class ScanProgress <<Value Object>> {
  + current_point: int
  + total_points: int
  + current_line: int
  + total_lines: int
  + elapsed_time_seconds: float
  + estimated_remaining_seconds: float
  
  + percentage() -> float
}

class MeasurementResult <<Value Object>> {
  + position: Position2D
  + timestamp: datetime
  + voltage: VoltageMeasurement
  + point_index: int
  + line_index: int
}

class ValidationResult <<Value Object>> {
  + is_valid: bool
  + errors: List[str]
  + warnings: List[str]
}

' ==========================================
' ENTITY (Agrégat)
' ==========================================

class SpatialScan <<Entity>> {
  + id: UUID
  + scan_type: str
  + is_fly_scan: bool
  + status: ScanStatus
  + start_time: Optional[datetime]
  + end_time: Optional[datetime]
  + results: List[Dict[str, Any]]
  
  + start() -> None
  + complete() -> None
  + fail(reason: str) -> None
  + cancel() -> None
  + add_result(result: Dict[str, Any]) -> None
}

enum ScanStatus <<Value Object>> {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  
  + is_final() -> bool
  + is_active() -> bool
}

' ==========================================
' PORTS (Abstractions infrastructure)
' ==========================================

interface IMotionPort <<Port>> {
  + move_to(position: Position2D) -> None
  + get_current_position() -> Position2D
  + is_moving() -> bool
  + wait_until_stopped() -> None
}

interface IAcquisitionPort <<Port>> {
  + acquire_sample() -> VoltageMeasurement
  + configure_for_uncertainty(uncertainty: MeasurementUncertainty) -> None
  + is_ready() -> bool
}

' ==========================================
' VALUE OBJECTS (Existants)
' ==========================================

class Position2D <<Value Object>> {
  + x: float
  + y: float
  
  + distance_to(other: Position2D) -> float
}

class VoltageMeasurement <<Value Object>> {
  ' Langage du domaine (ubiquitous language)
  ' Composantes du champ électrique mesurées
  + voltage_x_in_phase: float
  + voltage_x_quadrature: float
  + voltage_y_in_phase: float
  + voltage_y_quadrature: float
  + voltage_z_in_phase: float
  + voltage_z_quadrature: float
  + timestamp: datetime
  + uncertainty_estimate_volts: Optional[float]
  
  ' Mapping depuis ADC channels (documentation seulement):
  ' X in-phase = ADC1_Ch1
  ' X quadrature = ADC1_Ch2
  ' Y in-phase = ADC1_Ch3
  ' Y quadrature = ADC1_Ch4
  ' Z in-phase = ADC2_Ch1
  ' Z quadrature = ADC2_Ch2
  ' Le mapping réel est fait dans l'infrastructure (Adapter)
}

class MeasurementUncertainty <<Value Object>> {
  ' Concept métier : incertitude de mesure acceptable
  ' Exprimée en Volts (±), indépendante de l'implémentation hardware
  + max_uncertainty_volts: float
  
  + validate() -> ValidationResult
  + effective_number_of_bits(signal_range_volts: float) -> float
}

' ==========================================
' ENTITY (Future)
' ==========================================

class TestBench <<Entity>> {
  ' Entity représentant le banc physique
  ' Identité définie, existence durant toute
  ' la période d'utilisation du logiciel
  
  + id: UUID
  + name: str
  + x_max_cm: float
  + y_max_cm: float
  + z_max_cm: float
  
  ' TODO: Injecter limites physiques dans ScanZone
}

' ==========================================
' RELATIONS
' ==========================================

AutomaticStepScanService --> IMotionPort : "utilise"
AutomaticStepScanService --> IAcquisitionPort : "utilise"
AutomaticStepScanService ..> StepScanConfig : "configure avec"
AutomaticStepScanService ..> SpatialScan : "crée et gère"
AutomaticStepScanService ..> ScanProgress : "retourne"
AutomaticStepScanService ..> MeasurementResult : "génère"

StepScanConfig *-- ScanZone
StepScanConfig *-- ScanMode
StepScanConfig *-- MeasurementUncertainty

SpatialScan *-- ScanStatus
SpatialScan o-- MeasurementResult : "contient"

MeasurementResult *-- Position2D
MeasurementResult *-- VoltageMeasurement

IMotionPort ..> Position2D
IAcquisitionPort ..> VoltageMeasurement
IAcquisitionPort ..> MeasurementUncertainty

' ==========================================
' NOTES
' ==========================================

note right of AutomaticStepScanService
  **Domain Service = Logique métier pure**
  
  **Responsabilité:**
  Orchestrer un scan automatique par étapes:
  1. Valider configuration
  2. Générer trajectoire (serpentine/raster/comb)
  3. Pour chaque point:
     - Déplacer axes
     - Attendre stabilisation
     - Acquérir averaging_per_scan_point mesures
     - Moyenner (chaque mesure déjà moyennée par ADC)
     - Stocker résultat
  4. Gérer lifecycle (pause/resume/cancel)
  
  **Principe:**
  - Pas de dépendances infrastructure
  - Utilise des Ports (interfaces)
  - Logique métier testable en isolation
  - Pas de Qt, pas de threads, pas de fichiers
  
  **Injection de dépendances:**
  Les ports sont injectés au constructeur
  (Hexagonal Architecture)
end note

note bottom of IMotionPort
  **Port = Interface abstraite**
  
  Implémenté par l'infrastructure:
  - MotionAdapter (wraps StageManager)
  
  Permet de tester le service
  avec un mock/stub
end note

note bottom of IAcquisitionPort
  **Port = Interface abstraite**
  
  Implémenté par l'infrastructure:
  - AcquisitionAdapter (wraps AcquisitionManager)
  
  Traduit MeasurementUncertainty en configuration hardware:
  - Détermine gain, OSR, sampling rate pour atteindre l'incertitude cible
  - L'incertitude peut venir de multiples sources (quantification, bruit, etc.)
  
  Permet de tester le service avec un mock/stub
end note

note bottom of StepScanConfig
  **Configuration immuable**
  
  Validation à la création:
  - Zone valide (x_min < x_max, etc.)
  - Nombre de points > 0
  - Délai stabilisation >= 0
  - averaging_per_scan_point >= 1
  
  Calculs dérivés:
  - total_points = x_nb * y_nb
  - durée estimée
  
  **ScanZone valide les limites physiques:**
  - 0 <= x_min < x_max <= 120 cm
  - 0 <= y_min < y_max <= 120 cm
  (hardcodé pour MVP, injecté depuis TestBench plus tard)
  
  **Incertitude de mesure:**
  - measurement_uncertainty définit l'incertitude acceptable (±V)
  - L'infrastructure (Adapter) détermine comment l'atteindre (gain, OSR, averaging)
  
  **Deux niveaux de moyennage:**
  - Hardware (OSR de l'ADC) : géré par l'infrastructure
  - averaging_per_scan_point : logique métier du domain
  Total échantillons = OSR × averaging_per_scan_point
end note

note bottom of MeasurementUncertainty
  **Concept métier = Incertitude de mesure**
  
  Au lieu de spécifier des paramètres hardware (gains, OSR),
  le domain spécifie l'INCERTITUDE acceptable en Volts.
  
  L'infrastructure détermine comment atteindre cette incertitude
  (peut combiner quantification, bruit, averaging, calibration).
  
  **Exemple:**
  max_uncertainty_volts = 10µV (±10µV)
  → Infrastructure détermine: gain=32, OSR=512, averaging=10
  
  **Séparation domain/infrastructure:**
  - Domain: QUOI (incertitude acceptable ±V)
  - Infrastructure: COMMENT (configuration hardware + traitement)
end note

note bottom of SpatialScan
  **Entité = Agrégat racine**
  
  Gère le lifecycle du scan:
  - Transitions d'état validées
  - Accumulation des résultats
  - Timestamps start/end
  
  Identité = UUID
end note

@enduml
