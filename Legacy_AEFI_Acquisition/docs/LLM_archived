# Utilisation des moteurs avec arcusdevice.py

## Exemple de script Python pour piloter les moteurs

```python
from arcusdevice import ArcusDevice

device = ArcusDevice(port='COM3')  # Adapter le port si besoin
device.connect()

# Activer l'axe X
response_x = device.send_command('EO1')  # Enable Output 1 (axe X)
print('Activation X:', response_x)

# Activer l'axe Y
response_y = device.send_command('EO2')  # Enable Output 2 (axe Y)
print('Activation Y:', response_y)

# Exemple de déplacement absolu sur X et Y
# Mettre en mode absolu
print(device.send_command('ABS'))
# Déplacer X à la position 1000
print(device.send_command('X1000'))
# Déplacer Y à la position 2000
print(device.send_command('Y2000'))

# Arrêter les moteurs
print(device.send_command('STOP'))

# Fermer la connexion
device.close()
```

# Archivage des grandes étapes du projet

## Situation actuelle (2024-06-09)
- Objectif : Automatiser le pilotage des moteurs et l'acquisition de données sur le banc de test.
- Les moteurs sont déjà pilotés avec succès via Python.
- Prochaine étape : Automatiser l'acquisition de données (remplacement de LabVIEW par Python).
- Synchronisation à mettre en place entre le pilotage moteur et l'acquisition.
- Organisation des fichiers d'archivage :
    - LLM_bufferMemory : bloc-notes temporaire
    - LLM_log : journal détaillé, questions/réponses
    - LLM_archived : grandes étapes et jalons

## Migration vers une interface Python complète (2025-05-17)

### Architecture du projet `ArcusPerformaxPythonController`
- Séparation claire entre logique métier (controller) et interface utilisateur (gui)
- Utilisation de pylablib pour la communication avec le contrôleur Arcus Performax 4EX00

### Découvertes importantes
- La différence de comportement entre les axes X et Y est résolue en utilisant les commandes globales (LS, HS, ACC, DEC) plutôt que les commandes spécifiques à chaque axe
- Paramètres optimaux déterminés : LS=10, HS=800, ACC=300, DEC=300
- L'activation automatique des paramètres globaux avant chaque mouvement garantit un comportement cohérent

### Interface graphique
- Interface visuelle similaire à LabVIEW pour faciliter la transition
- Affichage en temps réel des positions
- Contrôles complets : homing, jog, stop, gestion des vitesses

### Prochaines étapes
- Développer l'interface d'acquisition de données
- Mettre en place la synchronisation entre moteurs et acquisition
- Intégrer le tout dans une interface unifiée 